[{"categories":["kubernetes"],"content":"Introdução Hoje eu aprendi sobre uma configuração de DNS do Kubernetes que existe em vários setups, talvez exista no seu e que nem eu, você nem saiba! ","date":"31-10-2021","objectID":"/pt-br/til_ndots_k8s/:0:0","tags":["k8s","dns","pod","ndots","throttling"],"title":"Kubernetes e performance de DNS - ndots","uri":"/pt-br/til_ndots_k8s/"},{"categories":["kubernetes"],"content":"Contexto Hoje eu aprendi sobre ndots. ndots é um parâmetro do arquivo /etc/resolv.conf que configura o número mínimo de pontos ( . ) que um nome (DNS) deve ter ","date":"31-10-2021","objectID":"/pt-br/til_ndots_k8s/:1:0","tags":["k8s","dns","pod","ndots","throttling"],"title":"Kubernetes e performance de DNS - ndots","uri":"/pt-br/til_ndots_k8s/"},{"categories":["kubernetes"],"content":"Cenário Dependendo do seu setup do kubernetes,os pods podem conter o seguinte conteúdo do resolv.conf : search default.svc.cluster.local svc.cluster.local cluster.local nameserver 10.96.0.10 options ndots:5 Reparem que o ndots está configurado para 5 Agora imagine que você tenha um serviço (apiv1/Service) chamado pagamentos e que hipoteticamente existam outros pod nesse cluster que utilizem o DNS interno para enviar requests ao serviço de pagamento. A url da request seria algo do tipo: pagamentos-svc.pagamentos.svc.cluster.local:3000 (4 pontos) O resolvedor de DNS vai dizer, pera lá 4 é menor que 5 e vai buscar esse domínio em cada um dos nameservers até achar o mesmo. default.svc.cluster.local svc.cluster.local cluster.local Agora imagine que esse cluster faz 5k de requests por segundo para o serviço de pagamentos. Pobre do kube-dns (ou core-dns tbm) né? CPU throttling vai lá em cima e os serviços começam a ficar mais lentos por causa de DNS A solução imediata seria adicionar um ponto ao fim da URL. pagamentos-svc.pagamentos.svc.cluster.local.:3000 isso vai fazer com que o resolvedor de DNS não pingue de nameserver em nameserver e tente resolver exatamente esse endereço. ","date":"31-10-2021","objectID":"/pt-br/til_ndots_k8s/:2:0","tags":["k8s","dns","pod","ndots","throttling"],"title":"Kubernetes e performance de DNS - ndots","uri":"/pt-br/til_ndots_k8s/"},{"categories":["kubernetes"],"content":"Testando Se vocẽ tem o prometheus rodando no seu cluster, você será capaz de visualizar a diferença facilmente. Crie alguns pods em uma namespace (X) e um service em outra namespace (Y) e escreva um script simples para forçar a resolução de nome, exemplo: for i in {1..5000}; do nslookup app.y.svc.cluster.local}; done e depois for i in {1..5000}; do nslookup app.y.svc.cluster.local.}; done E compare os gráficos de uso de CPU e requests no Grafana. ","date":"31-10-2021","objectID":"/pt-br/til_ndots_k8s/:3:0","tags":["k8s","dns","pod","ndots","throttling"],"title":"Kubernetes e performance de DNS - ndots","uri":"/pt-br/til_ndots_k8s/"},{"categories":["kubernetes"],"content":"Referências https://pracucci.com/kubernetes-dns-resolution-ndots-options-and-why-it-may-affect-application-performances.html https://man7.org/linux/man-pages/man5/resolv.conf.5.html ","date":"31-10-2021","objectID":"/pt-br/til_ndots_k8s/:4:0","tags":["k8s","dns","pod","ndots","throttling"],"title":"Kubernetes e performance de DNS - ndots","uri":"/pt-br/til_ndots_k8s/"},{"categories":["golang"],"content":"Introdução Algumas vezes que procurei no google por isso a resposta nao estava exatamente clara e como eu tenho uma memória horrível decidi criar esse post. ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:0","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"},{"categories":["golang"],"content":"Cenário Imagine a seguinte coleção de dados em uma collection do mongodb. { _id: 1, cust_id: \"abc1\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: \"A\", amount: 50 } { _id: 2, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-01T17:04:11.102Z\"), status: \"A\", amount: 100 } { _id: 3, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-12T17:04:11.102Z\"), status: \"D\", amount: 25 } { _id: 4, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-11T17:04:11.102Z\"), status: \"D\", amount: 125 } { _id: 5, cust_id: \"abc1\", ord_date: ISODate(\"2013-11-12T17:04:11.102Z\"), status: \"A\", amount: 25 }  E queremos saber o total de produtos por estado do pedido. Agrupamento/Group type OrderStatusTotal struct { ID string `bson:\"_id\"` Total int `bson:\"total\"` } pipelineResult := make([]OrderStatusTotal, 0) pipeline := make([]bson.M, 0) groupStage := bson.M{ \"$group\": bson.M{ \"_id\": \"$status\", \"total\": bson.M{\"$sum\": 1}, }, } pipeline = append(pipeline, groupStage) data, err := collection.Aggregate(ctx, pipeline) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to execute aggregation %s\", err.Error()) return } err = data.All(ctx, \u0026pipelineResult) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to decode results\", err.Error()) return } fmt.Printf(\"%+v\\n\", pipelineResult) } Agrupamento e Filtros/Group and Match type OrderStatusTotal struct { ID string `bson:\"_id\"` Total int `bson:\"total\"` } pipelineResult := make([]OrderStatusTotal, 0) pipeline := make([]bson.M, 0) groupStage := bson.M{ \"$group\": bson.M{ \"_id\": \"$status\", \"total\": bson.M{\"$sum\": 1}, }, } matchStage := bson.M{ \"$match\": bson.M{ \"cust_id\": \"abc1\", }, } pipeline = append(pipeline, matchStage,groupStage) data, err := collection.Aggregate(ctx, pipeline) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to execute aggregation %s\", err.Error()) return } err = data.All(ctx, \u0026pipelineResult) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to decode results\", err.Error()) return } fmt.Printf(\"%+v\\n\", pipelineResult) ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:1","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"},{"categories":["golang"],"content":"Notas O código deste post é um exemplo muito simples, não está pronto para produção. Para evitar dependencias externas eu costumo criar um type alias para as queries do mongo, exemplo: type DBQuery map[string]interface{} Evite usar interfaces vazias, isso só vai te causar nil pointers e muitos type assertions Documentação do mongo sobre agregações e pipelines Feedbacks são bem vindos :) Exemplo completo pode ser encondato aqui ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:2","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"}]