[{"categories":["golang"],"content":"Introdução Algumas vezes que procurei no google por isso a resposta nao estava exatamente clara e como eu tenho uma memória horrível decidi criar esse post. ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:0","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"},{"categories":["golang"],"content":"Cenário Imagine a seguinte coleção de dados em uma collection do mongodb. { _id: 1, cust_id: \"abc1\", ord_date: ISODate(\"2012-11-02T17:04:11.102Z\"), status: \"A\", amount: 50 } { _id: 2, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-01T17:04:11.102Z\"), status: \"A\", amount: 100 } { _id: 3, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-12T17:04:11.102Z\"), status: \"D\", amount: 25 } { _id: 4, cust_id: \"xyz1\", ord_date: ISODate(\"2013-10-11T17:04:11.102Z\"), status: \"D\", amount: 125 } { _id: 5, cust_id: \"abc1\", ord_date: ISODate(\"2013-11-12T17:04:11.102Z\"), status: \"A\", amount: 25 }  E queremos saber o total de produtos por estado do pedido. Agrupamento/Group type OrderStatusTotal struct { ID string `bson:\"_id\"` Total int `bson:\"total\"` } pipelineResult := make([]OrderStatusTotal, 0) pipeline := make([]bson.M, 0) groupStage := bson.M{ \"$group\": bson.M{ \"_id\": \"$status\", \"total\": bson.M{\"$sum\": 1}, }, } pipeline = append(pipeline, groupStage) data, err := collection.Aggregate(ctx, pipeline) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to execute aggregation %s\", err.Error()) return } err = data.All(ctx, \u0026pipelineResult) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to decode results\", err.Error()) return } fmt.Printf(\"%+v\\n\", pipelineResult) } Agrupamento e Filtros/Group and Match type OrderStatusTotal struct { ID string `bson:\"_id\"` Total int `bson:\"total\"` } pipelineResult := make([]OrderStatusTotal, 0) pipeline := make([]bson.M, 0) groupStage := bson.M{ \"$group\": bson.M{ \"_id\": \"$status\", \"total\": bson.M{\"$sum\": 1}, }, } matchStage := bson.M{ \"$match\": bson.M{ \"cust_id\": \"abc1\", }, } pipeline = append(pipeline, matchStage,groupStage) data, err := collection.Aggregate(ctx, pipeline) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to execute aggregation %s\", err.Error()) return } err = data.All(ctx, \u0026pipelineResult) if err != nil { log.Println(err.Error()) fmt.Errorf(\"failed to decode results\", err.Error()) return } fmt.Printf(\"%+v\\n\", pipelineResult) ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:1","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"},{"categories":["golang"],"content":"Notas O código deste post é um exemplo muito simples, não está pronto para produção. Para evitar dependencias externas eu costumo criar um type alias para as queries do mongo, exemplo: type DBQuery map[string]interface{} Evite usar interfaces vazias, isso só vai te causar nil pointers e muitos type assertions Documentação do mongo sobre agregações e pipelines Feedbacks são bem vindos :) Exemplo completo pode ser encondato aqui ","date":"13-05-2020","objectID":"/pt-br/go_mongo_aggregations/:0:2","tags":["golang","mongodb","agregação","pipelines"],"title":"Mongodb: Como fazer agregações/pipelines em Golang","uri":"/pt-br/go_mongo_aggregations/"}]